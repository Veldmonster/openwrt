--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
<<<<<<< HEAD
@@ -2363,6 +2363,7 @@ struct cfg80211_qos_map {
=======
@@ -2406,6 +2406,7 @@ struct cfg80211_qos_map {
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
  *	(as advertised by the nl80211 feature flag.)
  * @get_tx_power: store the current TX power into the dbm variable;
  *	return 0 if successful
+ * @set_antenna_gain: set antenna gain to reduce maximum tx power if necessary
  *
  * @set_wds_peer: set the WDS peer for a WDS interface
  *
<<<<<<< HEAD
@@ -2624,6 +2625,7 @@ struct cfg80211_ops {
=======
@@ -2667,6 +2668,7 @@ struct cfg80211_ops {
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
 				enum nl80211_tx_power_setting type, int mbm);
 	int	(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
 				int *dbm);
+	int	(*set_antenna_gain)(struct wiphy *wiphy, int dbi);
 
 	int	(*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev,
 				const u8 *addr);
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
<<<<<<< HEAD
@@ -1286,6 +1286,7 @@ enum ieee80211_smps_mode {
=======
@@ -1305,6 +1305,7 @@ enum ieee80211_smps_mode {
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
  *
  * @power_level: requested transmit power (in dBm), backward compatibility
  *	value only that is set to the minimum of all interfaces
+ * @max_antenna_gain: maximum antenna gain adjusted by user config (in dBi)
  *
  * @chandef: the channel definition to tune to
  * @radar_enabled: whether radar detection is enabled
<<<<<<< HEAD
@@ -1306,6 +1307,7 @@ enum ieee80211_smps_mode {
=======
@@ -1325,6 +1326,7 @@ enum ieee80211_smps_mode {
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
 struct ieee80211_conf {
 	u32 flags;
 	int power_level, dynamic_ps_timeout;
+	int max_antenna_gain;
 
 	u16 listen_interval;
 	u8 ps_dtim_period;
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
<<<<<<< HEAD
@@ -1790,6 +1790,9 @@ enum nl80211_commands {
  *	between scans. The scan plans are executed sequentially.
  *	Each scan plan is a nested attribute of &enum nl80211_sched_scan_plan.
=======
@@ -1819,6 +1819,9 @@ enum nl80211_commands {
  *
  * @NL80211_ATTR_PAD: attribute used for padding for 64-bit alignment
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
  *
+ * @NL80211_ATTR_WIPHY_ANTENNA_GAIN: Configured antenna gain. Used to reduce
+ *	transmit power to stay within regulatory limits. u32, dBi.
+ *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
<<<<<<< HEAD
@@ -2164,6 +2167,8 @@ enum nl80211_attrs {
 	NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS,
 	NL80211_ATTR_SCHED_SCAN_PLANS,
=======
@@ -2201,6 +2204,8 @@ enum nl80211_attrs {
 
 	NL80211_ATTR_PAD,
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
 
+	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
<<<<<<< HEAD
@@ -2229,6 +2229,19 @@ static int ieee80211_get_tx_power(struct
=======
@@ -2238,6 +2238,19 @@ static int ieee80211_get_tx_power(struct
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
 	return 0;
 }
 
+static int ieee80211_set_antenna_gain(struct wiphy *wiphy, int dbi)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	if (dbi < 0)
+		return -EINVAL;
+
+	local->user_antenna_gain = dbi;
+	ieee80211_hw_config(local, 0);
+
+	return 0;
+}
+
 static int ieee80211_set_wds_peer(struct wiphy *wiphy, struct net_device *dev,
 				  const u8 *addr)
 {
<<<<<<< HEAD
@@ -3403,6 +3416,7 @@ const struct cfg80211_ops mac80211_confi
=======
@@ -3412,6 +3425,7 @@ const struct cfg80211_ops mac80211_confi
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
 	.set_wiphy_params = ieee80211_set_wiphy_params,
 	.set_tx_power = ieee80211_set_tx_power,
 	.get_tx_power = ieee80211_get_tx_power,
+	.set_antenna_gain = ieee80211_set_antenna_gain,
 	.set_wds_peer = ieee80211_set_wds_peer,
 	.rfkill_poll = ieee80211_rfkill_poll,
 	CFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
<<<<<<< HEAD
@@ -1318,6 +1318,7 @@ struct ieee80211_local {
=======
@@ -1322,6 +1322,7 @@ struct ieee80211_local {
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
 	int dynamic_ps_forced_timeout;
 
 	int user_power_level; /* in dBm, for all interfaces */
+	int user_antenna_gain; /* in dBi */
 
 	enum ieee80211_smps_mode smps_mode;
 
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -93,7 +93,7 @@ static u32 ieee80211_hw_conf_chan(struct
 	struct ieee80211_sub_if_data *sdata;
 	struct cfg80211_chan_def chandef = {};
 	u32 changed = 0;
-	int power;
+	int power, max_power;
 	u32 offchannel_flag;
 
 	offchannel_flag = local->hw.conf.flags & IEEE80211_CONF_OFFCHANNEL;
@@ -150,6 +150,12 @@ static u32 ieee80211_hw_conf_chan(struct
 	}
 	rcu_read_unlock();
 
+	max_power = chandef.chan->max_reg_power;
+	if (local->user_antenna_gain > 0) {
+		max_power -= local->user_antenna_gain;
+		power = min(power, max_power);
+	}
+
 	if (local->hw.conf.power_level != power) {
 		changed |= IEEE80211_CONF_CHANGE_POWER;
 		local->hw.conf.power_level = power;
<<<<<<< HEAD
@@ -586,6 +592,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
=======
@@ -588,6 +594,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
 					 IEEE80211_RADIOTAP_MCS_HAVE_BW;
 	local->hw.radiotap_vht_details = IEEE80211_RADIOTAP_VHT_KNOWN_GI |
 					 IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH;
+	local->user_antenna_gain = 0;
 	local->hw.uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;
 	local->hw.uapsd_max_sp_len = IEEE80211_DEFAULT_MAX_SP_LEN;
 	local->user_power_level = IEEE80211_UNSET_POWER_LEVEL;
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
<<<<<<< HEAD
@@ -403,6 +403,7 @@ static const struct nla_policy nl80211_p
 	[NL80211_ATTR_NETNS_FD] = { .type = NLA_U32 },
 	[NL80211_ATTR_SCHED_SCAN_DELAY] = { .type = NLA_U32 },
 	[NL80211_ATTR_REG_INDOOR] = { .type = NLA_FLAG },
=======
@@ -406,6 +406,7 @@ static const struct nla_policy nl80211_p
 	[NL80211_ATTR_PBSS] = { .type = NLA_FLAG },
 	[NL80211_ATTR_BSS_SELECT] = { .type = NLA_NESTED },
 	[NL80211_ATTR_STA_SUPPORT_P2P_PS] = { .type = NLA_U8 },
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
+	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
 };
 
 /* policy for the key attributes */
<<<<<<< HEAD
@@ -2220,6 +2221,20 @@ static int nl80211_set_wiphy(struct sk_b
=======
@@ -2251,6 +2252,20 @@ static int nl80211_set_wiphy(struct sk_b
>>>>>>> 871372c42a3fc9c4b33f5c6011742d610a2e5600
 		if (result)
 			return result;
 	}
+
+	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_GAIN]) {
+		int idx, dbi = 0;
+
+		if (!rdev->ops->set_antenna_gain)
+			return -EOPNOTSUPP;
+
+		idx = NL80211_ATTR_WIPHY_ANTENNA_GAIN;
+		dbi = nla_get_u32(info->attrs[idx]);
+
+		result = rdev->ops->set_antenna_gain(&rdev->wiphy, dbi);
+		if (result)
+			return result;
+	}
 
 	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&
 	    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {
